/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

//#include <stdint.h>
#include <stdio.h>
#include <stdbool.h>
#include <main.h>
#include "usart.h"
#include "core_cm7.h"
#include "ymodem.h"
#include "flash.h"

UART_HandleTypeDef huart3;


static void CPU_CACHE_Enable(void);
void SystemClock_config(void);


int __io_putchar(int ch)
{
  uartWrite(2, (uint8_t *)&ch, 1);
  return 1;
}
/*
int _write(int file,uint8_t*ptr,int len)
{
  HAL_UART_Transmit_IT(&huart3,ptr,len);
  return len;
}
*/


void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();
  __HAL_RCC_GPIOG_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, LD1_Pin|LD3_Pin|LD2_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(USB_PowerSwitchOn_GPIO_Port, USB_PowerSwitchOn_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = USER_Btn_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(USER_Btn_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pins : PBPin PBPin PBPin */
  GPIO_InitStruct.Pin = LD1_Pin|LD3_Pin|LD2_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = USB_PowerSwitchOn_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(USB_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = USB_OverCurrent_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(USB_OverCurrent_GPIO_Port, &GPIO_InitStruct);

  /*Configure GPIO pin : PG14 */
  GPIO_InitStruct.Pin = GPIO_PIN_14;
  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  GPIO_InitStruct.Alternate = GPIO_AF8_USART6;
  HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);

}

void SystemClock_Config(void)
{
   RCC_OscInitTypeDef RCC_OscInitStruct = {0};
   RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
   RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};

   /** Configure LSE Drive Capability
   */
   HAL_PWR_EnableBkUpAccess();
   /** Configure the main internal regulator output voltage
   */
   __HAL_RCC_PWR_CLK_ENABLE();
   __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
   /** Initializes the RCC Oscillators according to the specified parameters
   * in the RCC_OscInitTypeDef structure.
   */
   RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
   RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
   RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
   RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
   RCC_OscInitStruct.PLL.PLLM = 4;
   RCC_OscInitStruct.PLL.PLLN = 216;
   RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
   RCC_OscInitStruct.PLL.PLLQ = 9;
   if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
   {
	 Error_Handler();
   }
   /** Activate the Over-Drive mode
   */
   if (HAL_PWREx_EnableOverDrive() != HAL_OK)
   {
	 Error_Handler();
   }
   /** Initializes the CPU, AHB and APB buses clocks
   */
   RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
							   |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
   RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
   RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
   RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
   RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;

   if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
   {
	 Error_Handler();
   }
   PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART3|RCC_PERIPHCLK_CLK48;
   PeriphClkInitStruct.Usart3ClockSelection = RCC_USART3CLKSOURCE_PCLK1;
   PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48SOURCE_PLL;
   if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
   {
	 Error_Handler();
   }
}

void Main_Menu(void)
{
	 printf("\r\n==========================================================");
	 printf("\r\n=    Intercon systems STM32F7XX Bootloader  ");
	 printf("\r\n     (Compiled: %s %s) --\r\n", __DATE__, __TIME__);
	 printf("\r\n==========================================================\r\n");

	 CPU (Embedded Processor):   Freescale i.MX6SX rev1.3 at 792 MHz
	 CPU Temperature 43 C
	 Embedded Processor          Cortex-M3.
	 Architecture identifier     AT91SAM3UExx Series.
	 Board: MX6SX SABRE SDB
	 Reset cause: POR
	 Nonvolatile program memory type           Embedded Flash Memory.
	 Nonvolatile program memory size           256K bytes.
	 Second nonvolatile program memory size    None.
	 Internal SRAM size   :  1 GiB
	 PMIC:  PFUZE100 ID=0x11
	 SF: Detected N25Q256 with page size 256 Bytes, erase size 4 KiB, total 32 MiB
	 In:    serial
	 Out:   serial
	 Err:   serial
	 Net:   Phy 1 not found
	 Normal Boot
	 Extended chip ID is not existed.
	 Hit enter key to stop autoboot:  0

}
#if 0
void check_image(void)
{
	printf("\r\n\r\n");

	printf("Checking Bootloader...");
	ret = DiagFlash_CheckImage(0x8010000);
	if(ret != 0)
	{
		printf("FAIL\r\n");
/*		result = -1;*/		/* TODO : Application 이미지만 정상이면 부팅 가능.. ?? */
	}
	else
	{
		printf("OK\r\n\r\n");
		printf("[ Bootloader Information ]\r\n");
		PrintImageStat(0x8010000);
	}

	printf("\r\n");

	printf("Checking Application...");
	ret = DiagFlash_CheckImage(CONFIG_APP_BASE);
	if(ret != 0)
	{
		printf("FAIL\r\n");
		result = -1;
	}
	else
	{
		printf("OK\r\n");
		printf("[ Application Information ]\r\n\r\n");
		PrintImageStat(CONFIG_APP_BASE);
	}

	printf("\r\n");

	return(result);
}
#endif

int32_t BootApplication(void)
{
	//if(DiagFlash_CheckImage(0x8010000) == 0)
	//{
	uint32_t JumpAddress;

	 	JumpAddress = *(__IO uint32_t*) (0x8010000+4);
		printf("\r\nBooting at 0x%08X...\r\n\r\n", (void*)JumpAddress);

//		  USBD_DeInit();
		  HAL_RCC_DeInit();

		  // Disable Interrupts
		  //
		  for (int i=0; i<8; i++)
		  {
			NVIC->ICER[i] = 0xFFFFFFFF;
			__DSB();
			__ISB();
		  }
		  SysTick->CTRL = 0;

		void (**jump_func)(void) = (void (**)(void))(0x8010000 + 4);

		(*jump_func)();
		/* Initialize user application's Stack Pointer */
		//JumpToApplication();
		return(0);
/*	}
	else
	{
		printf("\r\nCannot boot at 0x%08X, image has been corrupted\r\n\r\n", (void*)JumpAddress);
		return(-1);
	}*/
}

/* USER CODE BEGIN 4 */
static void CPU_CACHE_Enable(void)
{
  /* Enable I-Cache */
  SCB_EnableICache();

  /* Enable D-Cache */
  SCB_EnableDCache();
}

/* USER CODE END 4 */

/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void delay(uint32_t ms)
{
	HAL_Delay(ms);
}
uint32_t millis(void)
{
	return HAL_GetTick();
}

void Error_Handler(void)
{
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
}

int main(void)
{
	uint32_t pre_time;
	uint32_t k=16;

//	CPU_CACHE_Enable();


	HAL_Init();
	SystemClock_Config();

	//SystemInit();
	MX_GPIO_Init();
	cdcInit();
	cliInit();
	MX_USB_DEVICE_Init();

	uartOpen(1,51200);
	uartOpen(2,115200);

	//cliOpen(1,51200);

	flashInit();
	ymodemInit();
	cliFlash();


	/*
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif //...? 확인 필요.
*/

	 printf("start MCU\r\n");
	 pre_time = millis();
	 printf("\r\n\r\n-- # booting (Compiled: %s %s) --\r\n", __DATE__, __TIME__);
     Main_Menu();

	  while(1)
	  {
		  if(millis()-pre_time >= 500)
		  {
			  pre_time = millis();
			  HAL_GPIO_TogglePin(GPIOB, LD1_Pin);
		  }
//		  BootApplication();
		  cliMain();

		  /*
		  if(uartAvailable(2)>0)
		  {
			  uint8_t rx_data;

			  rx_data = uartRead(2);
			  printf("uart Rx :  0x%X \r\n",rx_data);

			  cliMain();*/
#if 0
			  if(rx_data == '1')
			  {
				  uint8_t buf[32];

				  printf("Read....\r\n");
				  flashRead(0x08000000+(180*1024),buf,32);
				  for(int i=0; i<32; i++)
				  {
					 //printf("0x0%X : 0x%X\r\n",0x08000000+(180*1024)+i,buf[i]);
				  }
			  }

			  if(rx_data == '2')
			  {
				  printf("Erase.......");

				  if(flashErase(0x08000000+(180*1024),32) == true){
					  printf("Ok!!\r\n");
				  }
				  else
				  {
					  printf("Fail\r\n");
				  }
			   }

			  if(rx_data == '3')
			  {
				  uint8_t buf[32];
				  for(int i=0; i<32; i++)
				  {
					 buf[i]=k;
					 k++;
				  }
				  printf("Write...\r\n");
				  if(flashWrite(0x08000000+(180*1024),buf,32) == true){
					  printf("Ok!!\r\n");
				  }
				  else
				  {
					  printf("Fail\r\n");
				  }
			  }
				if(rx_data == '4')
				{
				  ReadFlash();
				}

		  }
#endif

	  }

	    /* USER CODE END Error_Handler_Debug */

}

